
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
    <title>
        Multiple Animations - Samples - Turbulenz Engine
    </title>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8" >
    <style type="text/css">
html, body, div, span, object, iframe, h1, h2, p, a, img, ul, li, fieldset, form, label, legend, table, thead, tbody, tfoot, tr, th, td {
    border: 0;
    font-size: 100%;
    margin: 0;
    outline: 0;
    padding: 0;
    vertical-align: baseline;
}
    </style>
    <!-- block tz_app_header -->
    
    <link rel="stylesheet" type="text/css" href="css/base_template.css">
    <link rel="shortcut icon" href="img/favicon.ico">
    <link rel="Stylesheet" type="text/css" href="css/jquery-ui-1.8.2.custom.css"/>
    <script type="text/javascript" src="js/jquery-1.4.2.min.js"></script>
    <script type="text/javascript" src="js/jquery-ui-1.8.2.custom.min.js"></script>

    <!-- end tz_app_header -->
</head>
<body style="background:#B4B4B4;font:normal normal normal 13px/1.231 Helvetica,Arial,sans-serif;text-shadow:1px 1px #F9F8F8;">
    <div id="titlebar" style="position:fixed;height:65px;top:0;right:0;left:0;">
        <strong style="font-size:24px;line-height:64px;margin:16px;">
            <!-- block tz_app_title_name -->
            Multiple Animations
            <!-- end tz_app_title_name -->
        </strong>
        <div id="titlelogo"
             style="float:right;width:27px;height:27px;margin:18px 24px;">
        </div>
    </div>
    <div id="sidebar"
         style="background:#B4B4B4;position:fixed;width:303px;top:65px;left:0;">
        <!-- block tz_app_html_controls -->
        
<div class="html-control control-output-pair">Performance: <strong id="fpscounter" class="control-output"></strong></div>
<div class="html-control control-output-pair">Character grid size: <input type="text" id="slider1input" size="2" value="0" class="control-textfield"></div>
<div class="html-control control-slider">
    <div id="slider1" class="sliderinput"></div>
</div>

        <!-- end tz_app_html_controls -->
    </div>
    <div id="engine" style="background:#939393;position:fixed;top:65px;
                            bottom:0;right:0;left:303px;
                            border-left:1px solid #898989;">
        <!--
          HTML to create a plugin or canvas instance.
          Supplied by 'tz_engine_div' variable.
        -->
        
        <canvas id="turbulenz_game_engine_canvas" moz-opaque="true" tabindex="1">
            Sorry, but your browser does not support WebGL or does not have it
            enabled.  To get a WebGL-enabled browser, please see:<br/>
            <a href="http://www.khronos.org/webgl/wiki/Getting_a_WebGL_Implementation" target="_blank">
                Getting a WebGL Implementation
            </a>
        </canvas>

        <script type="text/javascript">
            var canvasSupported = true;
            (function()
            {
                var contextNames = ["webgl", "experimental-webgl"];
                var context = null;
                var canvas = document.createElement('canvas');

                document.body.appendChild(canvas);

                for (var i = 0; i < contextNames.length; i += 1)
                {
                    try {
                        context = canvas.getContext(contextNames[i]);
                    } catch (e) {}

                    if (context) {
                        break;
                    }
                }
                if (!context)
                {
                    canvasSupported = false;
                    window.alert("Sorry, but your browser does not support WebGL or does not have it enabled.");
                }

                document.body.removeChild(canvas);
            }());
            var TurbulenzEngine = {};
        </script>
    </div>

    <!-- begin 'tz_include_js' variable -->
    <script type="text/javascript" src="jslib/debug.js"></script>
<script type="text/javascript" src="jslib/vmath.js"></script>
<script type="text/javascript" src="jslib/utilities.js"></script>
<script type="text/javascript" src="jslib/aabbtree.js"></script>
<script type="text/javascript" src="jslib/observer.js"></script>
<script type="text/javascript" src="jslib/webgl/ddsloader.js"></script>
<script type="text/javascript" src="jslib/webgl/graphicsdevice.js"></script>
<script type="text/javascript" src="jslib/webgl/inputdevice.js"></script>
<script type="text/javascript" src="jslib/webgl/mathdevice.js"></script>
<script type="text/javascript" src="jslib/webgl/networkdevice.js"></script>
<script type="text/javascript" src="jslib/webgl/physicsdevice.js"></script>
<script type="text/javascript" src="jslib/webgl/sounddevice.js"></script>
<script type="text/javascript" src="jslib/webgl/soundtarloader.js"></script>
<script type="text/javascript" src="jslib/webgl/tarloader.js"></script>
<script type="text/javascript" src="jslib/webgl/tgaloader.js"></script>
<script type="text/javascript" src="jslib/webgl/touch.js"></script>
<script type="text/javascript" src="jslib/webgl/touchevent.js"></script>
<script type="text/javascript" src="jslib/webgl/turbulenzengine.js"></script>
<script type="text/javascript" src="jslib/camera.js"></script>
<script type="text/javascript" src="jslib/geometry.js"></script>
<script type="text/javascript" src="jslib/material.js"></script>
<script type="text/javascript" src="jslib/light.js"></script>
<script type="text/javascript" src="jslib/scenenode.js"></script>
<script type="text/javascript" src="jslib/scene.js"></script>
<script type="text/javascript" src="jslib/effectmanager.js"></script>
<script type="text/javascript" src="jslib/shadermanager.js"></script>
<script type="text/javascript" src="jslib/texturemanager.js"></script>
<script type="text/javascript" src="jslib/renderingcommon.js"></script>
<script type="text/javascript" src="jslib/defaultrendering.js"></script>
<script type="text/javascript" src="jslib/resourceloader.js"></script>
<script type="text/javascript" src="jslib/animationmanager.js"></script>
<script type="text/javascript" src="jslib/animation.js"></script>
<script type="text/javascript" src="jslib/requesthandler.js"></script>
<script type="text/javascript" src="jslib/vertexbuffermanager.js"></script>
<script type="text/javascript" src="jslib/indexbuffermanager.js"></script>
<script type="text/javascript" src="jslib/services/turbulenzservices.js"></script>
<script type="text/javascript" src="jslib/services/turbulenzbridge.js"></script>
<script type="text/javascript" src="jslib/services/gamesession.js"></script>
<script type="text/javascript" src="jslib/services/mappingtable.js"></script>
<script type="text/javascript" src="scripts/sceneloader.js"></script>
<script type="text/javascript" src="scripts/motion.js"></script>
<script type="text/javascript" src="scripts/htmlcontrols.js"></script>
    <!-- end 'tz_include_js' variable -->

    <script type="text/javascript">
      // ----------------------------------------
      // Embedded code and startup code.
      // Supplied by 'tz_startup_code' variable.
      // ----------------------------------------
      
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};




























/*global TurbulenzEngine: false */
/*global RequestHandler: false */
/*global DefaultRendering: false */
/*global TurbulenzServices: false */
/*global Camera: false */
/*global TextureManager: false */
/*global ShaderManager: false */
/*global EffectManager: false */
/*global AnimationManager: false */
/*global Scene: false */
/*global SkinnedNode: false */
/*global GPUSkinController: false */
/*global SceneLoader: false */
/*global ResourceLoader: false */
/*global InterpolatorController: false */
/*global VMath: false */
/*global HTMLControls: false */
/*global window: false */
// HACK: TypeScript 0.9.0 removes the above comments without this
// (since the comments get associated with the declare, which
// generates no code).
void 0;

TurbulenzEngine.onload = function onloadFn() {
    var errorCallback = function errorCallback(msg) {
        window.alert(msg);
    };

    var graphicsDeviceParameters = {};
    var graphicsDevice = TurbulenzEngine.createGraphicsDevice(graphicsDeviceParameters);

    if (!graphicsDevice.shadingLanguageVersion) {
        errorCallback("No shading language support detected.\nPlease check your graphics drivers are up to date.");
        graphicsDevice = null;
        return;
    }

    // Clear the background color of the engine window
    var clearColor = [0.5, 0.5, 0.5, 1.0];
    if (graphicsDevice.beginFrame()) {
        graphicsDevice.clear(clearColor);
        graphicsDevice.endFrame();
    }

    var mathDeviceParameters = {};
    var mathDevice = TurbulenzEngine.createMathDevice(mathDeviceParameters);

    var requestHandlerParameters = {};
    var requestHandler = RequestHandler.create(requestHandlerParameters);

    var textureManager = TextureManager.create(graphicsDevice, requestHandler, null, errorCallback);
    var shaderManager = ShaderManager.create(graphicsDevice, requestHandler, null, errorCallback);
    var effectManager = EffectManager.create();
    var animationManager = AnimationManager.create(errorCallback);

    // The model used for this sample only has 20 bones so we optimize for it.
    // Ideally you will modify the source shader code instead of patching at runtime
    // but this is done here for convenience.
    shaderManager.setAutomaticParameterResize("skinBones", 20 * 3);

    var resourceLoader = ResourceLoader.create();
    var scene = (Scene.create(mathDevice));
    var sceneLoader = SceneLoader.create();
    var mappingTable;
    var renderer;

    // Setup world space
    var worldUp = mathDevice.v3BuildYAxis();

    // Setup a camera to view a close-up object
    var camera = Camera.create(mathDevice);
    camera.nearPlane = 0.05;
    camera.updateViewMatrix();

    var animMinExtent, animMaxExtent;

    var cameraDistanceFactor = 1.2;
    var cameraDir = [-1, 1, -1];

    // Settings for the animation
    var settings = {
        animScale: 1,
        defaultRate: 1,
        drawDebug: false,
        drawInterpolators: false,
        drawWireframe: false,
        loopAnimation: true
    };

    // This is our base asset that includes a character and animations
    var assetToLoad = "models/Seymour.dae";

    var character = {
        count: 64,
        max: 400,
        min: 1,
        lastCount: 1,
        startPos: [0.0, 0.0, 0.0],
        gridSpace: 0.1,
        baseAngle: 135,
        varAngle: 270,
        height: 0.1
    };

    var deg2Rad = (Math.PI / 180);

    // Materials to use for grid characters
    var materials = {
        seymour10: {
            parameters: {
                diffuse: "textures/boy_10.png"
            },
            effect: "lambert"
        },
        seymour20: {
            parameters: {
                diffuse: "textures/boy_20.png"
            },
            effect: "lambert"
        },
        seymour30: {
            parameters: {
                diffuse: "textures/boy_30.png"
            },
            effect: "lambert"
        },
        seymour40: {
            parameters: {
                diffuse: "textures/boy_40.png"
            },
            effect: "lambert"
        },
        seymour50: {
            parameters: {
                diffuse: "textures/boy_50.png"
            },
            effect: "lambert"
        }
    };

    // Helper function for setting material on skeleton hierarchy
    var setMaterialHierarchy = function setMaterialHierarchyFn(scene, node, materialName) {
        var renderables = node.renderables;
        if (renderables) {
            var material = scene.getMaterial(materialName);
            var numRenderables = renderables.length;
            for (var i = 0; i < numRenderables; i += 1) {
                renderables[i].setMaterial(material);
            }
        }
        var children = node.children;
        if (children) {
            var numChildren = children.length;
            for (var c = 0; c < numChildren; c += 1) {
                var child = children[c];
                setMaterialHierarchy(scene, child, materialName);
            }
        }
    };

    // The list of animations to load pre-scene load (by reference)
    // This is only for animations that are not included in the default scene
    // e.g. "animations/default_walking.anim"
    var addAnimations = ["models/Seymour_anim2_rot90_anim_only.dae"];

    // The list of animations to be removed from the scene data pre-load
    // This is for undesired animations that are packed in the scene
    // All these animations are not required for this sample
    var removeAnimations = [
        "default_astroboy_w_skel02_gog_polySurface5",
        "default_astroboy_w_skel02_polySurface5",
        "default_astroboy_w_skel02c_gog_polySurface5",
        "default_astroboy_w_skel02c_polySurface5",
        "default_gog_polySurface5",
        "default_polySurface5"
    ];

    var animationsLoaded;

    // When the JSON is loaded, add a prefix to uniquely identify that set of animation data
    var animationsLoadedCallback = function animationsLoadedCallbackFn(jsonData) {
        var addAnimNum = (addAnimations.length - animationsLoaded);
        animationManager.loadData(jsonData, "AnimExtra" + addAnimNum + "-");
        animationsLoaded -= 1;
    };

    var addAnimationsToScene = function addAnimationsToSceneFn() {
        // Attach additional animations to the scene (specify by path)
        // The animations are added by reference and the scene will attempt to load them using request
        animationsLoaded = addAnimations.length;
        for (var i = 0; i < addAnimations.length; i += 1) {
            var path = addAnimations[i];
            resourceLoader.load(mappingTable.getURL(path), {
                append: true,
                onload: animationsLoadedCallback,
                requestHandler: requestHandler
            });
        }
    };

    var removeAnimationsFromScene = function removeAnimationsFromSceneFn(sceneData) {
        // Remove unrequired animations from scene, if they exist before load
        var anims = sceneData.animations;
        var animationRef;

        if (anims) {
            for (var i = 0; i < removeAnimations.length; i += 1) {
                animationRef = removeAnimations[i];
                if (anims[animationRef]) {
                    delete anims[animationRef];
                }
            }
        }
    };

    // Calculates a position for the camera to lookAt
    var resetCamera = function resetCameraFn(camera) {
        var ceil = Math.ceil;
        var ex = character.gridSpace * ceil(Math.sqrt(character.count));
        animMinExtent = mathDevice.v3BuildZero();
        animMaxExtent = mathDevice.v3Build(ex, character.height, ex);

        // Update the camera to scale to the size of the scene
        var center = mathDevice.v3ScalarMul(mathDevice.v3Add(animMaxExtent, animMinExtent), 0.5);
        var extent = mathDevice.v3Sub(center, animMinExtent);

        camera.lookAt(center, worldUp, mathDevice.v3Build(center[0] + extent[0] * cameraDistanceFactor * cameraDir[0], center[1] + extent[1] * cameraDistanceFactor * cameraDir[1] * 4, center[2] + extent[2] * cameraDistanceFactor * cameraDir[2]));
        camera.updateViewMatrix();

        // Calculates the appropriate nearPlane for the animation extents
        var len = VMath.v3Length(extent);
        if (len < 4.0) {
            camera.nearPlane = len * 0.1;
        } else {
            camera.nearPlane = 1.0;
        }
        camera.farPlane = ceil(len) * 100.0;
        camera.updateProjectionMatrix();
    };

    // Controls
    var htmlControls = HTMLControls.create();

    var slider01ID = "slider1";

    htmlControls.addSliderControl({
        id: slider01ID,
        value: character.count,
        max: character.max,
        min: character.min,
        step: 1,
        fn: function () {
            var val = this.value;
            character.count = val;
            htmlControls.updateSlider(slider01ID, val);
        }
    });

    htmlControls.register();

    // Initialise character animations
    var initCharacters = function initCharactersFn() {
        var n, i, j, k, x, y, node, characterAngle;

        var nodeHasSkeleton = animationManager.nodeHasSkeleton;
        var sceneNodes = scene.rootNodes;
        var numNodes = sceneNodes.length;
        var random = Math.random;
        var floor = Math.floor;
        var ceil = Math.ceil;

        // We want to create resources for the maximum grid elements we want to use
        var gridDim = ceil(Math.sqrt(character.max));
        var gridSpace = character.gridSpace;
        var startX = character.startPos[0];
        var startY = character.startPos[2];
        var varAngle = character.varAngle;
        var halfVarAngle = varAngle / 2;
        var baseAngle = character.baseAngle;
        var currentNodeIndex = 0;

        var newNodes = [];

        // These will be the reference node hierarchies for each material we use
        // Instead of cloning the base node in the scene we will clone the reference node, because the material is already set
        var referenceNodes = [];
        referenceNodes.push("seymour10");
        referenceNodes.push("seymour20");
        referenceNodes.push("seymour30");
        referenceNodes.push("seymour40");
        referenceNodes.push("seymour50");

        var refLength = referenceNodes.length;

        var nodePos, nodeMaterialID, refNode, newNode, nodeName, matrix;
        var v3Build = mathDevice.v3Build;
        var m43FromAxisRotation = mathDevice.m43FromAxisRotation;
        var m43SetPos = mathDevice.m43SetPos;

        for (n = 0; n < numNodes; n += 1) {
            node = sceneNodes[n];
            var skeleton = nodeHasSkeleton(node);
            if (skeleton) {
                for (i = 0; i < gridDim; i += 1) {
                    for (j = 0; j < gridDim; j += 1) {
                        if ((i === 0) && (j === 0)) {
                            // Use the orginal node as the basis, so don't create one
                            node.gridNum = 1;
                            continue;
                        }
                        nodeMaterialID = floor(refLength * random()) % refLength;
                        refNode = referenceNodes[nodeMaterialID];
                        if (typeof refNode === 'string') {
                            // Create the first instance of the node, from the material name 'refNode'
                            nodeName = node.name + "_" + refNode;
                            newNode = scene.cloneRootNode(node, nodeName);

                            // Sets the material on this node and its children
                            setMaterialHierarchy(scene, newNode, refNode);

                            // Assign the new hierarchy as a reference
                            referenceNodes[nodeMaterialID] = newNode;
                        } else {
                            // Clone the reference node
                            newNode = scene.cloneRootNode(refNode, refNode.name + currentNodeIndex);
                        }

                        // CharacterAngle is the random angle of rotation
                        characterAngle = baseAngle + (halfVarAngle - (varAngle * random()));

                        // x and y are the top down grid positions
                        x = (i * gridSpace) + startX;
                        y = (j * gridSpace) + startY;
                        nodePos = v3Build.call(mathDevice, x, 0, y);

                        // Create a matrix from the angle
                        matrix = m43FromAxisRotation.call(mathDevice, worldUp, characterAngle * deg2Rad);
                        m43SetPos.call(mathDevice, matrix, nodePos);
                        newNode.setLocalTransform(matrix);

                        // Set the grid position identifiers for our nodes
                        // We can find the node grid position later
                        newNode.gridX = i;
                        newNode.gridY = j;

                        if (i > j) {
                            k = (i + 1);
                            k *= k;
                            newNode.gridNum = k - (2 * i) + j;
                        } else {
                            k = (j + 1);
                            k *= k;
                            newNode.gridNum = k - j + i;
                        }

                        newNodes.push(newNode);
                        currentNodeIndex += 1;
                    }
                }
            }
        }
    };

    // Initialise all animations with InterpolatorControllers set to start time
    var initAnimations = function initAnimationsFn(scene) {
        var a, n, interp, skinnedNode, node;
        var nodeHasSkeleton = animationManager.nodeHasSkeleton;
        var sceneNodes = scene.rootNodes;
        var sceneAnimations = animationManager.getAll();
        var numNodes = sceneNodes.length;

        var random = Math.random;
        var floor = Math.floor;

        var animations = [];
        var animationsLength = 0;

        for (a in sceneAnimations) {
            if (sceneAnimations.hasOwnProperty(a)) {
                animations.push(sceneAnimations[a]);
            }
        }
        animationsLength = animations.length;

        scene.skinnedNodes = [];

        var randomIndex = 0;

        for (n = 0; n < numNodes; n += 1) {
            node = sceneNodes[n];
            var skeleton = nodeHasSkeleton(node);
            if (skeleton) {
                // Randomly select an animation
                randomIndex = (floor(random() * 100) + randomIndex) % animationsLength;
                var animation = animations[randomIndex];

                // Create an interpolation controller
                interp = InterpolatorController.create(animation.hierarchy);
                interp.setAnimation(animation, settings.loopAnimation);

                // Set a different start time for each looping animation (for variation)
                interp.setTime(animation.length * random());
                interp.setRate(settings.defaultRate);

                // Create a skinnedNode
                skinnedNode = SkinnedNode.create(graphicsDevice, mathDevice, node, skeleton, interp);
                skinnedNode.active = false;
                scene.skinnedNodes.push(skinnedNode);
            }
        }

        return true;
    };

    // Initialize the previous frame time
    var previousFrameTime = 0;
    var nextGridUpdateTime = 0;
    var fpsElement = document.getElementById("fpscounter");
    var lastFPS = '';

    var updateFPSCounter = function updateFPSCounterFn() {
        fpsElement.innerHTML = (lastFPS + ' fps');
    };

    var renderFrame = function renderFrameFn() {
        var skinnedNodes, numSkins, skinnedNode, sceneNode, skin;
        var currentCharacterCount = character.count;
        var resetGrid = false;

        var currentTime = TurbulenzEngine.getTime();
        var deltaTime = (currentTime - previousFrameTime) * 0.001;
        if (deltaTime > 0.1) {
            deltaTime = 0.1;
        }

        if (currentTime >= nextGridUpdateTime) {
            nextGridUpdateTime = (currentTime + 0.5);

            resetGrid = (currentCharacterCount !== character.lastCount);
            character.lastCount = currentCharacterCount;

            if (fpsElement) {
                var currentFPS = (graphicsDevice.fps).toFixed(2);
                if (lastFPS !== currentFPS) {
                    lastFPS = currentFPS;

                    // Execute any code that interacts with the DOM in a separate callback
                    TurbulenzEngine.setTimeout(updateFPSCounter, 1);
                }
            }
        }

        if (resetGrid) {
            resetCamera(camera);
        }

        var deviceWidth = graphicsDevice.width;
        var deviceHeight = graphicsDevice.height;
        var aspectRatio = (deviceWidth / deviceHeight);
        if (aspectRatio !== camera.aspectRatio) {
            camera.aspectRatio = aspectRatio;
            camera.updateProjectionMatrix();
        }
        camera.updateViewProjectionMatrix();

        skinnedNodes = scene.skinnedNodes;
        numSkins = skinnedNodes.length;

        for (skin = 0; skin < numSkins; skin += 1) {
            skinnedNode = skinnedNodes[skin];
            sceneNode = skinnedNode.node;

            if (resetGrid) {
                var gridNum = sceneNode.gridNum;
                if (gridNum !== undefined) {
                    skinnedNode.active = (gridNum <= currentCharacterCount);
                } else {
                    // Default model or not in the grid, so set active
                    skinnedNode.active = true;
                }
            }

            if (skinnedNode.active) {
                if (sceneNode.getDisabled()) {
                    sceneNode.enableHierarchy(true);
                }

                // The skinned node will peform the update
                skinnedNode.addTime(deltaTime);
                skinnedNode.update(true);
            } else {
                if (!sceneNode.getDisabled()) {
                    sceneNode.enableHierarchy(false);
                }
            }
        }

        scene.update();

        renderer.update(graphicsDevice, camera, scene, currentTime);

        if (graphicsDevice.beginFrame()) {
            if (renderer.updateBuffers(graphicsDevice, deviceWidth, deviceHeight)) {
                renderer.draw(graphicsDevice, clearColor);
            }

            graphicsDevice.endFrame();
        }

        previousFrameTime = currentTime;
    };

    var intervalID;
    var loadingLoop = function loadingLoopFn() {
        if (sceneLoader.complete() && animationsLoaded === 0) {
            TurbulenzEngine.clearInterval(intervalID);

            // Adds character nodes to the scene
            initCharacters();

            // Init the animations from the scene
            initAnimations(scene);

            // Intial reset of the camera
            resetCamera(camera);

            renderer.updateShader(shaderManager);

            // Update the slider
            htmlControls.updateSlider(slider01ID, undefined);

            intervalID = TurbulenzEngine.setInterval(renderFrame, 1000 / 60);

            previousFrameTime = TurbulenzEngine.getTime();
        }
    };
    intervalID = TurbulenzEngine.setInterval(loadingLoop, 1000 / 10);

    var loadAssets = function loadAssetsFn() {
        // Renderer for the scene (requires shader assets).
        renderer = DefaultRendering.create(graphicsDevice, mathDevice, shaderManager, effectManager);

        renderer.setGlobalLightPosition(mathDevice.v3Build(0.5, 100.0, 0.5));
        renderer.setAmbientColor(mathDevice.v3Build(0.3, 0.3, 0.4));
        renderer.setDefaultTexture(textureManager.get("default"));

        for (var m in materials) {
            if (materials.hasOwnProperty(m)) {
                var material = materials[m];

                if (!material.loaded) {
                    material.loaded = scene.hasMaterial(m);
                }

                if (!material.loaded) {
                    material.loaded = scene.loadMaterial(graphicsDevice, textureManager, effectManager, m, material);
                }
            }
        }

        // Create object using scene loader
        sceneLoader.load({
            scene: scene,
            assetPath: assetToLoad,
            graphicsDevice: graphicsDevice,
            mathDevice: mathDevice,
            textureManager: textureManager,
            effectManager: effectManager,
            shaderManager: shaderManager,
            animationManager: animationManager,
            requestHandler: requestHandler,
            preSceneLoadFn: function (sceneData) {
                // Apply the modifications to the sceneData from assetPath
                addAnimationsToScene();
                removeAnimationsFromScene(sceneData);
            },
            keepLights: true,
            append: true,
            vertexFormatMap: {
                "BLENDINDICES": "UBYTE4",
                "NORMAL": "BYTE4N",
                "BLENDWEIGHT": "UBYTE4N"
            }
        });
    };

    var mappingTableReceived = function mappingTableReceivedFn(mappingTable) {
        textureManager.setPathRemapping(mappingTable.urlMapping, mappingTable.assetPrefix);
        shaderManager.setPathRemapping(mappingTable.urlMapping, mappingTable.assetPrefix);
        sceneLoader.setPathRemapping(mappingTable.urlMapping, mappingTable.assetPrefix);

        loadAssets();
    };

    var gameSessionCreated = function gameSessionCreatedFn(gameSession) {
        mappingTable = TurbulenzServices.createMappingTable(requestHandler, gameSession, mappingTableReceived);
    };
    var gameSession = TurbulenzServices.createGameSession(requestHandler, gameSessionCreated);

    // Create a scene destroy callback to run when the window is closed
    TurbulenzEngine.onunload = function destroyScene() {
        TurbulenzEngine.clearInterval(intervalID);

        if (gameSession) {
            gameSession.destroy();
            gameSession = null;
        }
        mappingTable = null;

        if (scene) {
            scene.destroy();
            scene = null;
        }
        requestHandler = null;
        sceneLoader = null;

        htmlControls = null;

        if (renderer) {
            renderer.destroy();
            renderer = null;
        }

        addAnimations = null;
        removeAnimations = null;

        materials = null;

        settings = null;
        character = null;

        camera = null;
        cameraDir = null;

        animMinExtent = [];
        animMaxExtent = [];

        clearColor = [];
        worldUp = [];

        if (textureManager) {
            textureManager.destroy();
            textureManager = null;
        }

        if (shaderManager) {
            shaderManager.destroy();
            shaderManager = null;
        }

        effectManager = null;

        fpsElement = null;

        TurbulenzEngine.flush();
        graphicsDevice = null;
        mathDevice = null;
    };
};

        // Engine startup
        window.onload = function ()
        {
            var appEntry = TurbulenzEngine.onload;
            var appShutdown = TurbulenzEngine.onunload;
            if (!appEntry) {
                window.alert("TurbulenzEngine.onload has not been set");
                return;
            }

            var canvas =
                document.getElementById('turbulenz_game_engine_canvas');

            var startCanvas = function startCanvasFn()
            {
                if (canvas.getContext && canvasSupported)
                {
                    TurbulenzEngine = WebGLTurbulenzEngine.create({
                        canvas: canvas,
                        fillParent: true
                    });

                    if (!TurbulenzEngine) {
                        window.alert("Failed to init TurbulenzEngine (canvas)");
                        return;
                    }

                    TurbulenzEngine.onload = appEntry;
                    TurbulenzEngine.onunload = appShutdown;
                    appEntry()
                }
            }

            var previousOnBeforeUnload = window.onbeforeunload;
            window.onbeforeunload = function ()
            {
                if (TurbulenzEngine.onunload) {
                    TurbulenzEngine.onunload.call(this);
                }
            };  // window.beforeunload

            startCanvas();
        };  // window.onload()

    </script>

</body>
</html>